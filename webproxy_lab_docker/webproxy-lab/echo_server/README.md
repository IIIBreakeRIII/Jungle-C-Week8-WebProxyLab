# echo_server 동작 구조

`echo_server/` 디렉터리의 파일들은 클라이언트-서버 모델의 기본적인 예제인 **에코(echo)** 기능을 구현합니다. 에코란, 클라이언트가 서버에 어떤 메시지를 보내면 서버가 그 메시지를 그대로 클라이언트에게 돌려주는 것을 의미합니다.

---

## 1. 서버 측 (`echoserveri.c`, `echo.c`)

서버는 클라이언트의 접속을 기다리고, 접속이 이루어지면 클라이언트가 보내는 메시지를 그대로 되돌려주는 역할을 합니다.

### `echoserveri.c` (메인 서버 프로그램)

1.  **`main` 함수 시작**:
    *   `argc`, `argv`를 통해 프로그램 실행 시 포트 번호를 인자로 받습니다. (`./echoserveri <port>`)
    *   인자가 2개(프로그램 이름, 포트)가 아니면 사용법을 출력하고 종료합니다.

2.  **듣기 소켓(Listening Socket) 생성**:
    *   `listenfd = Open_listenfd(argv[1]);`
    *   `Open_listenfd` 함수를 호출하여 지정된 포트에서 클라이언트의 접속을 기다리는 **듣기 소켓**(`listenfd`)을 생성합니다. 서버의 "정문"을 여는 과정과 같습니다.

3.  **무한 루프 진입**:
    *   `while (1)`: 서버는 종료되지 않고 계속해서 새로운 클라이언트의 접속을 받아야 하므로 무한 루프를 돕니다.

4.  **클라이언트 접속 대기 및 수락**:
    *   `connfd = Accept(listenfd, ...);`
    *   `Accept` 함수에서 멈춰서(block) 클라이언트가 접속할 때까지 기다립니다.
    *   클라이언트가 접속하면, `Accept` 함수는 그 클라이언트와 실제로 통신할 때 사용할 새로운 소켓인 **연결 소켓**(`connfd`)을 반환합니다.
    *   `listenfd`는 다른 클라이언트의 접속을 받기 위해 계속 열려 있고, `connfd`는 방금 접속한 특정 클라이언트와의 1:1 통신 채널이 됩니다.

5.  **에코 기능 수행**:
    *   `Getnameinfo(...)`: 접속한 클라이언트의 IP 주소와 포트 번호를 알아내어 화면에 출력합니다.
    *   `echo(connfd);`
    *   실제 통신은 `echo` 함수에게 위임합니다. 이때 통신용 소켓인 `connfd`를 넘겨줍니다.

6.  **연결 종료**:
    *   `echo` 함수가 반환되면, 이는 클라이언트와의 통신이 끝났다는 의미입니다.
    *   `Close(connfd);`: 클라이언트와의 1:1 통신 채널이었던 연결 소켓을 닫아 리소스를 해제합니다.
    *   다시 루프의 처음으로 돌아가 다음 클라이언트의 접속을 기다립니다.

### `echo.c` (실제 통신 담당)

*   **`echo` 함수**:
    *   `echoserveri`로부터 `connfd`를 인자로 받습니다.
    *   `Rio_readinitb(&rio, connfd);`: `connfd`로부터 데이터를 안정적으로 읽기 위해 `rio` 버퍼를 초기화합니다.
    *   `while ((n = Rio_readlineb(&rio, buf, MAXLINE)) != 0)`:
        *   `Rio_readlineb` 함수를 통해 클라이언트로부터 한 줄의 데이터를 읽어 `buf`에 저장합니다. (클라이언트가 접속을 끊으면 0이 반환되어 루프가 종료됩니다.)
        *   `Rio_writen(connfd, buf, n);`: `buf`에 저장된, 방금 클라이언트로부터 받은 데이터를 **그대로** 다시 클라이언트에게 보냅니다. 이것이 "에코" 기능의 핵심입니다.

---


## 2. 클라이언트 측 (`echoclient.c`)

클라이언트는 사용자가 키보드로 입력한 메시지를 서버에 보내고, 서버로부터 되돌아온 메시지를 화면에 출력하는 역할을 합니다.

1.  **`main` 함수 시작**:
    *   `argc`, `argv`를 통해 접속할 서버의 주소와 포트 번호를 인자로 받습니다. (`./echoclient <host> <port>`)

2.  **서버에 연결**:
    *   `clientfd = Open_clientfd(host, port);`
    *   `Open_clientfd` 함수를 호출하여 `host`, `port`에 해당하는 서버에 TCP 연결을 시도하고, 통신에 사용할 소켓(`clientfd`)을 얻습니다.

3.  **사용자 입력 및 서버 통신 루프**:
    *   `while (Fgets(buf, MAXLINE, stdin) != NULL)`:
        *   `Fgets` 함수를 통해 사용자가 키보드로 입력한 한 줄을 `buf`에 읽어들입니다. (사용자가 Ctrl+D를 누르면 `NULL`이 반환되어 루프가 종료됩니다.)
        *   `Rio_writen(clientfd, buf, strlen(buf));`: 사용자가 입력한 `buf`의 내용을 서버로 전송합니다.
        *   `Rio_readlineb(&rio, buf, MAXLINE);`: 서버가 다시 보내준 "에코" 메시지를 `buf`에 읽어들입니다.
        *   `Fputs(buf, stdout);`: 서버로부터 받은 `buf`의 내용을 사용자 화면(표준 출력)에 보여줍니다.

4.  **연결 종료**:
    *   루프가 끝나면 `Close(clientfd);`를 통해 서버와의 연결을 끊고 프로그램을 종료합니다.

---


## 3. 헬퍼 및 유틸리티 파일

### `csapp.c` / `csapp.h` (CS:APP 라이브러리)

`echoserver`와 `echoclient` 코드 전반에 사용되는 `Open_listenfd`, `Accept`, `Rio_readlineb` 등과 같은 함수들의 실제 구현을 담고 있습니다.

*   **역할**: 표준 시스템 콜(e.g., `socket`, `accept`, `read`, `write`)을 한 번 감싸는(wrap) **래퍼 함수(wrapper function)**를 제공합니다.
*   **주요 특징**: **에러 처리**를 내장하고 있습니다. 만약 시스템 콜이 실패하면, 래퍼 함수가 자동으로 에러 메시지를 출력하고 프로그램을 종료시켜 줍니다. 이 덕분에 메인 로직인 `echoserveri.c`나 `echoclient.c`의 코드가 `if (error) ...` 같은 반복적인 에러 처리 코드 없이 깔끔하게 유지될 수 있습니다.

### `hostinfo.c` (호스트 정보 유틸리티)

이 파일은 독립적으로 실행 가능한 유틸리티 프로그램입니다. 에코 서버/클라이언트의 직접적인 일부는 아니지만, 네트워크 프로그래밍 시 유용한 도구입니다.

*   **실행 방법**: `./hostinfo <hostname>` (e.g., `./hostinfo www.google.com`)
*   **기능**:
    1.  커맨드 라인 인자로 받은 호스트 이름(`hostname`)을 `getaddrinfo` 함수에 전달합니다.
    2.  `getaddrinfo`가 반환한 주소 정보 목록을 순회합니다.
    3.  해당 호스트 이름에 연결된 모든 IP 주소(코드에서는 IPv4로 한정)를 찾아서 표준 출력으로 인쇄합니다.

이 프로그램을 통해 특정 도메인 이름이 어떤 IP 주소들을 가지고 있는지 쉽게 확인할 수 있습니다.

---


## 4. 전체 동작 시나리오 요약

1.  **서버 실행**: 사용자가 터미널에 `./echoserveri 8192`를 입력합니다. 서버는 8192번 포트를 열고 `Accept` 함수에서 클라이언트의 접속을 기다립니다.
2.  **클라이언트 실행**: 다른 터미널에 사용자가 `./echoclient localhost 8192`를 입력합니다. 클라이언트는 `localhost:8192`에 접속을 시도합니다.
3.  **연결 수립**: 서버의 `Accept`가 리턴되며, 클라이언트와 통신할 `connfd`가 생성됩니다. 서버는 `echo(connfd)`를 호출합니다.
4.  **데이터 전송**: 클라이언트 터미널에서 사용자가 "hello"를 입력하고 엔터를 칩니다.
5.  `echoclient`는 "hello\n"를 서버로 보냅니다.
6.  `echoserveri`의 `echo` 함수는 "hello\n"를 받고, 그대로 다시 클라이언트로 보냅니다.
7.  `echoclient`는 서버로부터 "hello\n"를 받고, 이것을 터미널 화면에 출력합니다.
8.  **연결 종료**: 클라이언트 터미널에서 사용자가 Ctrl+D를 누릅니다. `echoclient`는 접속을 끊고 종료됩니다. 서버의 `echo` 함수도 `Rio_readlineb`이 0을 반환하여 종료되고, 서버는 `connfd`를 닫은 후 다시 다음 클라이언트를 기다립니다.
