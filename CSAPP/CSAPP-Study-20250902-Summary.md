# CSAPP 스터디 요약 (동시성 프로그래밍)

- **오디오 길이**: 0:59:59 (총 59.98분)
- **요약 최소 분량 기준**: 10분당 2,000자 ⇒ **최소 11997자** 필요

## 1) 큰 흐름
이번 스터디는 *Computer Systems: A Programmer’s Perspective* 12장(동시성) 핵심을 따라, **프로세스 기반**, **I/O 다중화 기반(select)**, **스레드 기반** 세 가지 동시성 구현을 비교‧분석했습니다. 또한 파일 디스크립터/파일 테이블/참조 카운트, 좀비 프로세스 수거, 이벤트 기반 상태기계, POSIX 스레드 API(pthread_create/join/exit/cancel/detach/once)와 스레드 메모리 모델(전역/지역자동/지역static)을 실제 에코 서버 사례에 맞춰 정리했습니다.

## 2) 프로세스 기반 동시성
- **아이디어**: 부모 프로세스는 `listen`/`accept`로 새 연결만 받고, **연결마다 자식**을 `fork()`로 생성해 요청을 처리.
- **장점**: 각 연결이 **격리**되며, 자식이 블록되어도 다른 연결(자식)에는 영향이 작음.
- **주의점**
  - **좀비 프로세스**: 부모가 `waitpid(-1, &status, WNOHANG)`를 **SIGCHLD 핸들러**와 조합해 **비동기 수거(reap)** 해야 함. 미수거 시 **프로세스 테이블/FD 테이블 고갈** 위험.
  - **FD/파일 테이블/참조 카운트**: `fork()` 후 부모와 자식은 같은 **오픈 파일 테이블 엔트리**를 가리키므로 **refcount** 증가. 자식이 더 이상 `listenfd`가 필요 없으면 **즉시 close**해야 **연결 종료 감지**와 자원 해제가 올바르게 동작.

## 3) I/O 다중화 기반 동시성 (select)
- **문제 배경**: 단일 프로세스가 `accept()`와 `read()`를 **모두 블록킹**으로 호출하면, 하나가 잠자는 동안 다른 이벤트를 놓칠 수 있음.
- **해결**: `select(nfds, &readfds, &writefds, &exceptfds, &timeout)`로 **여러 FD를 동시에 감시**. 하나라도 준비되면 깨어나 **준비된 것만 처리**.
- **핵심 매크로**: `FD_ZERO`, `FD_SET(fd, &set)`, `FD_CLR`, `FD_ISSET`.
- **비트벡터 집합**: `fd_set`은 FD 인덱스에 해당하는 비트를 1로 세팅.
- **오염 방지**: `select()`가 집합을 **파괴적으로 갱신**하므로, **원본(read_set)**과 **작업용(tmp_set)** 을 분리.
- **중첩 블로킹 주의**: 상위 루프에서 `stdin`/`listenfd`만 감시했는데, **하위 처리(Echo) 내부**에서 또 블록킹 `read()`가 등장하면 **전체 진행이 멈춤**. ⇒ 감시 대상에 **하위 단계에서 블록 가능성 있는 모든 FD**를 **풀(pool)** 구조로 **누적**하여, **더 세밀한 멀티플렉싱**을 구현.
- **이벤트 기반 서버**: 각 연결을 **상태기계(FSM)** 로 모델링(예: `WAIT_READ → READ_READY → PROCESS → WRITE_READY ...`). `select()`가 이벤트(준비 상태)를 알려주면 **상태 전이**로 처리.
- **장단점**
  - 장점: **컨텍스트 스위칭 비용 없음**, **단일 프로세스 내 전역 제어 용이**, 디버깅 시 **전체 흐름 가시성**.
  - 단점(세분성/그래뉼러리티): 한 악의적 클라이언트가 **CPU를 오래 점유**하거나 **반쪽짜리 입력**만 보내며 루틴을 붙잡아 두면, **같은 프로세스의 다른 흐름 전체가 지연**될 수 있음.

## 4) 스레드 기반 동시성 (POSIX Threads)
- **개념**: 하나의 **프로세스 주소 공간을 공유**하는 **여러 실행 흐름**. 각 스레드는 **ID, PC, 레지스터 집합, 스택** 등 **작은 컨텍스트**만 갖기 때문에 **컨텍스트 스위칭이 빠름**.
- **관계**: `pthread_create()`로 만든 스레드는 **자식이 아니라 피어(peer)**. 엄격한 부모-자식 위계가 아닌 **동등 관계**로 서로를 `pthread_join()`하거나 `pthread_cancel()` 가능.
- **수명/종료**
  - **암묵 종료**: 스레드 루틴이 `return`.
  - **명시 종료**: `pthread_exit(void *retval)`.
  - **취소**: 다른 스레드가 `pthread_cancel(tid)`.
  - **수거(리핑)**: `pthread_join(tid, &ret)`은 **특정 스레드 하나**만 기다리며, **사용하던 자원(스택 등)을 회수**.
  - **분리(detach)**: `pthread_detach(tid)` 또는 스레드 내부 `pthread_detach(pthread_self())`로 **조인 불가 상태**로 전환 ⇒ **종료 시 시스템이 자동 회수**.
  - **원칙**: 스레드는 **반드시** *joinable* 상태에서 `pthread_join()` 하거나, **detach** 중 하나로 귀결되어 **자원 누수 방지**.
- **한 번만 초기화**: `pthread_once_t once = PTHREAD_ONCE_INIT; pthread_once(&once, init_fn);` ⇒ 여러 스레드가 호출해도 **단 한 번** 실행.
- **스레드형 에코 서버 패턴**
  1) 메인: `listen` 후 반복적으로 `accept()`.
  2) **연결 FD를 동적 메모리**에 저장(예: `int *connp = malloc(sizeof(int)); *connp = connfd;`).
  3) 새 스레드 생성: `pthread_create(&tid, NULL, thread, connp);`
  4) 스레드 루틴: `pthread_detach(pthread_self());` → `echo(*connp); free(connp); close(connfd);`
- **레이스 컨디션 방지**
  - **나쁜 예**: 전역/지역의 **공유 변수 `connfd`** 를 스레드가 읽기 전에 메인이 값 갱신 ⇒ **여러 스레드가 같은 FD**를 다루는 경합.
  - **해결**: **연결마다 별도 힙 블록**에 FD를 복사해 전달(소유권 명확화), 스레드 루틴에서 사용 후 `free()`.
- **메모리 모델과 공유**
  - **공유됨**: 프로세스의 **가상 메모리 전체**(텍스트, 힙, 전역/정적, 공유 라이브러리), **열린 파일 집합**.
  - **비공유**: **레지스터 집합**, **스택**(단, OS가 스택 간 접근을 강제 차단하진 않으므로 주소를 넘기면 간접 접근 가능).
  - **변수 종류별**
    - **전역변수**: 인스턴스 1개 → 모든 스레드가 동일 인스턴스를 참조/갱신.
    - **지역 자동변수**: 스레드별 스택에 **서로 다른 인스턴스**.
    - **지역 static 변수**: 인스턴스 1개(전역과 유사) → 모든 스레드가 공유.
  - **포인터 공유 주의**: 메인 스레드의 지역 배열 주소를 피어에게 전달하면, **그 시점부터 공유 데이터**가 됨.

## 5) 세 모델 비교
- **프로세스 기반**: 격리와 안정성 ↑, 생성/스위칭 비용 ↑, 좀비 수거/FD 관리 필요.
- **select 기반**: 단일 주소 공간에서 **폭넓은 제어**와 **낮은 오버헤드**, 하지만 **한 루틴이 오래 점유**하면 전체가 지연될 위험.
- **스레드 기반**: 공유가 쉬워 **프로그래밍 생산성** ↑, **레이스/데이터 경쟁**과 **자원 회수** 규율을 반드시 지켜야 안정적.

## 6) 실무 체크리스트
- **프로세스 방식**
  - `SIGCHLD` 핸들러 + `waitpid(..., WNOHANG)`로 **즉시 reap**.
  - 자식이 필요 없는 **FD 즉시 close**(refcount/EOF 신호 정확화).
- **select 방식**
  - 모든 잠재적 블로킹 FD를 **풀에 등록**해 **상태 기반 처리**.
  - `FD_ZERO`/`FD_SET`/`FD_ISSET` 올바른 사용 + 원본/작업 집합 분리.
- **스레드 방식**
  - **FD/데이터의 소유권**을 명시화(힙 복사 전달).
  - 스레드마다 **detach 또는 join**의 **정책을 일관**되게 적용.
  - 공유자원 보호에 **뮤텍스/세마포어/조건변수** 도입을 전제.

---

> 본 요약은 발화 내용(원문 전사)의 오기/혼동 표현을 CSAPP의 표준 표기(예: `waitpid`, `SIGCHLD`, `fd_set`, `pthread_*` 등)로 정정하여 기술했습니다.
