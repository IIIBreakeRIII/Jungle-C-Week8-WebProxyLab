# CSAPP 스터디 요약 (Audio: 23분 44초)

**총 학습 시간**: 23분 44초  
**요약 최소 분량 기준**: 10분당 2,000자 → 총 **최소 4,748자** 이상

---

## 세션 개요
이번 스터디는 *Computer Systems: A Programmer’s Perspective*의 시스템 **입출력(I/O)** 단원을 중심으로, 리눅스/유닉스 I/O 모델과 프로그래밍 인터페이스의 동작 원리, 그리고 실전에서 마주치는 **short count** 문제와 이를 해결하기 위한 **강건(Robust) I/O, RIO 패키지**의 설계를 체계적으로 검토했습니다. 대화 중간에 잡담이 섞여 있으나, 핵심 내용은 다음의 흐름을 따릅니다.

- I/O의 정의와 범위: 메모리와 다양한 외부 장치(디스크, 터미널, 네트워크) 간 **데이터 복사**로서의 I/O
- 유닉스 관점의 **“모든 것은 파일”** 추상화: 장치까지 파일로 모델링 → 읽기/쓰기의 통일된 인터페이스
- **파일 디스크립터**와 **표준 I/O**(0: stdin, 1: stdout, 2: stderr), **파일 오프셋**과 `lseek`
- 시스템 콜 `open`/`close`/`read`/`write`의 의미, 반환값, 오류, **EOF** 처리
- **파일 유형**(일반 파일/디렉터리/소켓 등)과 **경로**(절대/상대), 셸 명령 개관
- **short count**의 원인(EOF, 터미널 라인 단위, 파이프/네트워크 버퍼링)과 **반복 루프** 전략
- **RIO(robust I/O)**: `readn`/`writen`(정확한 바이트 보장)과 버퍼드 라인/블록 읽기의 내부 동작
- **HTTP 헤더 파싱** 사례: 줄 단위(readline)와 본문 길이(Content-Length)에 따른 블록 읽기

---

## 1) 시스템 I/O의 관점 정리
- **I/O는 데이터 복사 작업**입니다. 입력은 **장치 → 메인 메모리**, 출력은 **메인 메모리 → 장치**로의 복사로 이해합니다. 키보드·마우스·디스크·터미널·네트워크 등이 모두 대상이 됩니다.
- 유닉스/리눅스는 장치를 **파일로 모델링**하므로, 응용은 **읽기/쓰기**라는 동일한 인터페이스로 대부분의 I/O를 수행합니다. 커널은 장치와 파일 간의 **매핑**과 자원 관리를 담당합니다.
- **런타임 표준 I/O(libc의 `printf/scanf` 등)**는 **버퍼링된 고수준 I/O**를 제공하지만, **메타데이터 접근**, **정밀 제어**, **네트워크/파이프의 부분 전송** 같은 상황에서는 **유닉스 I/O(시스템 콜)**가 필수입니다.

### 파일 디스크립터와 표준 스트림
- 프로세스는 시작 시 보통 **세 개의 열린 파일**을 가집니다: `0`(stdin), `1`(stdout), `2`(stderr).  
- 커널은 열린 파일마다 **파일 오프셋 k**를 유지합니다(초기 0). `read`가 n바이트를 읽으면 k는 `k+n`으로, `write`도 동일하게 진행됩니다.
- **EOF**는 “특정 문자”가 아니라 **상황**으로 감지합니다. `read` 결과가 0이면 **파일 끝**에 도달한 것입니다.

### 파일 위치 변경(`lseek`)
- `lseek`으로 현재 파일 위치(오프셋)를 명시적으로 이동할 수 있습니다.  
- 오프셋이 파일 크기 **m**을 초과한 상태에서 읽기를 시도하면 **즉시 EOF**에 해당하는 0을 반환합니다.

---

## 2) 시스템 콜 인터페이스
### `open(path, flags, mode)`
- **반환값**: 사용 중이지 않은 **가장 작은 정수 FD**를 반환.
- **`flags`**: 읽기 전용/쓰기 전용/읽기-쓰기(`O_RDONLY/O_WRONLY/O_RDWR`), 생성(`O_CREAT`), 추가(`O_APPEND`), 존재 시 오류(`O_EXCL`), 트렁케이트(`O_TRUNC`) 등과 **비트 OR**로 결합.
- **`mode`**: 파일 생성 시 접근 권한 비트. 예: 사용자/그룹/기타의 읽기·쓰기·실행(`S_IRUSR`, `S_IWUSR`, …). `umask`와 결합되어 최종 권한이 결정됩니다.
- 스터디에서는 권한 비트 마스크를 예로 들며 **`rwxrwxrwx`** 형태의 해석을 복습했습니다.

### `close(fd)`
- 커널이 관리하던 **오픈 상태/커널 자료구조를 해제**합니다. 프로세스 종료 시 커널이 자동 정리하지만, **명시적 `close`**로 자원을 제때 반납하는 습관이 중요합니다.

### `read(fd, buf, n) / write(fd, buf, n)`
- `read` 반환값 > 0: 실제로 읽은 바이트 수, `0`: **EOF**, `-1`: 오류.  
- `write`는 요청한 바이트보다 **더 적게 쓰고** 반환할 수 있습니다(부분 전송 가능).  
- 따라서 **반복 루프**로 누적 처리해야 안전합니다.

---

## 3) 파일/디렉터리/경로와 셸 명령
- **일반 파일**: 텍스트/바이너리의 구분은 **응용 레벨** 개념이며 커널은 바이트 시퀀스로 취급합니다. 텍스트 라인은 보통 `\n`으로 끝납니다.
- **디렉터리**: “이름 → 파일”을 매핑하는 **링크들의 배열**. 현재 디렉터리 `.` , 상위 디렉터리 `..`.
- **경로명**: `/`로 시작하면 **절대경로**, 그렇지 않으면 **상대경로**. 현재 작업 디렉터리 기준으로 해석합니다.
- **명령 정리**: `ls`(목록), `mkdir`(생성), `rmdir`(삭제), `rm`(파일 삭제). *(대화 중 “rmdr/dir”로 언급된 부분은 `rmdir`의 오기였음을 바로잡았습니다.)*

---

## 4) Short Count(부분 전송)과 그 원인
**Short count**는 요청한 바이트 수보다 **적게 읽거나/쓰는** 상황을 말합니다. 스터디에서 다음 원인을 짚었습니다.
1. **EOF 도달**: 디스크 파일의 끝에 닿아 더 이상 읽을 데이터가 없는 경우.
2. **터미널(라인 단위 전송)**: 줄 경계를 기준으로 입력이 도중 끊길 수 있음.
3. **네트워크/파이프**: TCP는 **바이트 스트림**으로 “메시지 경계”가 없으므로, 커널 버퍼/네트워크 상태에 따라 한 번의 `read`/`write`로는 **요청량이 충족되지 않음**.

> 결론: **반드시 루프**를 돌며 **남은 바이트 수를 갱신**하고, 포인터를 **전진**시키면서 **누적** 처리해야 합니다. 시스템 콜을 반복 호출하므로 비용이 늘 수 있는데, 이것을 **정확성**과 **성능**을 함께 만족시키도록 다룬 것이 **RIO**입니다.

---

## 5) Robust I/O (RIO) 패턴
### 5.1 비버퍼드 정확 전송: `readn`/`writen`
- 목표: **딱 요청한 바이트 수를 보장**.  
- 아이디어: 내부에서 `read`/`write`를 **반복 호출**하여 `nleft`가 0이 될 때까지 누적하고, 일시적 중단(일부 신호/조건) 시 **재시도**합니다.
- 흐름(읽기 예시):  
  1) `nleft = n`으로 시작 → 2) `nread = read(fd, bufp, nleft)` → 3) `nleft -= nread`, `bufp += nread` → 4) `nleft == 0`이면 종료, 아니면 반복.  
- 쓰기도 동일한 패턴으로 **부분 쓰기**에 대응합니다.

### 5.2 버퍼드 RIO: 라인/블록 읽기
- 목표: 시스템 콜 호출 **오버헤드 절감** + **편의성**.  
- 내부에 **고정 크기 버퍼(관례적으로 8192바이트)** 를 두고, 커널에서 **덩어리로 읽어 채워둔 뒤** 사용자가 요청하는 크기/라인에 맞춰 **내부 복사**로 응답합니다.
- **라인 읽기(`rio_readlineb`)**: 내부 버퍼에서 **개행 문자를 기준**으로 한 줄을 안전하게 반환. HTTP **헤더 파싱**에 적합.
- **블록 읽기(`rio_readnb`)**: 사용자가 지정한 바이트 수만큼 **버퍼에서 제공**하고, 부족하면 커널에서 재보충.

### 5.3 HTTP 요청 처리 예
- 헤더는 **길이가 고정돼 있지 않으므로** 라인 단위로 읽어 **빈 줄**(header/body 구분)까지 처리합니다.  
- 그 후 헤더의 `Content-Length` 값을 참조하여 **본문은 블록 단위**로 정확히 읽습니다.  
- 이때 라인/블록 API를 **혼합**하면 **가독성**과 **정확성**을 모두 만족시킬 수 있습니다.

---

## 6) 스터디 중 논의/질문 포인트 정리
- **FD 할당 규칙**: “프로세스에서 사용 중이지 않은 **가장 작은** FD를 반환”을 사례로 확인했습니다.
- **표준 I/O vs 유닉스 I/O**: 전자는 **편의/버퍼링** 중심, 후자는 **정밀 제어/시스템 콜 직접 사용**에 유리. 네트워크/동시성/메타데이터 접근에는 유닉스 I/O가 필요.
- **오류 처리**: `read` 반환 0(EOF)과 `-1`(오류)을 **구분**해야 하며, 짧게 읽혔을 때도 루프를 통해 **남은 바이트**를 보장하는 습관이 중요.

---

## 7) 실전 체크리스트
- [ ] 파일 열기 시 `flags`/`mode`를 **명확히** 지정하고, `umask` 영향 고려  
- [ ] 모든 `read`/`write`는 **부분 전송**을 가정해 루프 처리  
- [ ] 네트워크 I/O는 **메시지 경계가 없다(TCP)** 는 사실을 항상 기억  
- [ ] 라인 프로토콜(예: HTTP 헤더)은 **라인 읽기** + 본문은 **바이트 정확 보장**으로 처리  
- [ ] 열린 FD는 **반드시 `close`** (에러 경로 포함)  

---

## 8) 용어/오해 바로잡기
- `seek` → 유닉스에서는 보통 **`lseek`** 시스템 콜로 표현합니다.  
- 디렉터리 삭제 명령은 **`rmdir`** 입니다.  
- EOF는 **특정 문자**가 아니라 **상황**이며, `read`가 **0**을 반환할 때로 식별합니다.

---

## 9) 한 줄 요약
**유닉스 I/O의 본질은 “바이트 스트림을 정확하고 효율적으로 주고받는 것”**이며, 이를 위해 **부분 전송을 전제로 한 반복 루프**와 **RIO 같은 보조 추상화**가 핵심 도구입니다.

